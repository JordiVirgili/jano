import requests
import re
from urllib.parse import urljoin, urlparse
from typing import Dict, Any, List, Optional
from eris.core.plugins import AttackPlugin


class WebVulnerabilityPlugin(AttackPlugin):
    def __init__(self):
        self.timeout = 10
        self.user_agent = "Eris-Security-Scanner/1.0"

        # Common vulnerability payloads
        self.xss_payloads = ["<script>alert('XSS')</script>", "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>"]

        self.sql_payloads = ["' OR '1'='1", "' UNION SELECT NULL--", "'; DROP TABLE users--"]

    def initialize(self, config: Dict[str, Any]) -> None:
        self.timeout = config.get("timeout", self.timeout)
        self.user_agent = config.get("user_agent", self.user_agent)

    def _test_xss_vulnerability(self, url: str) -> Dict[str, Any]:
        vulnerabilities = []

        for payload in self.xss_payloads:
            try:
                # Test GET parameter injection
                test_url = f"{url}?test={payload}"
                response = requests.get(test_url, timeout=self.timeout, headers={"User-Agent": self.user_agent})

                if payload in response.text:
                    vulnerabilities.append({"type": "reflected_xss", "location": "GET parameter", "payload": payload,
                        "evidence": response.text[:200]})

            except requests.RequestException:
                continue

        return {"xss_vulnerabilities": vulnerabilities}

    def _test_sql_injection(self, url: str) -> Dict[str, Any]:
        vulnerabilities = []

        for payload in self.sql_payloads:
            try:
                test_url = f"{url}?id={payload}"
                response = requests.get(test_url, timeout=self.timeout, headers={"User-Agent": self.user_agent})

                # Check for SQL error indicators
                sql_errors = ["SQL syntax error", "mysql_fetch_array", "ORA-[0-9]{4,5}", "Microsoft OLE DB Provider"]

                for error_pattern in sql_errors:
                    if re.search(error_pattern, response.text, re.IGNORECASE):
                        vulnerabilities.append(
                            {"type": "sql_injection", "location": "GET parameter", "payload": payload,
                                "error_pattern": error_pattern, "evidence": response.text[:200]})
                        break

            except requests.RequestException:
                continue

        return {"sql_vulnerabilities": vulnerabilities}

    def _check_security_headers(self, url: str) -> Dict[str, Any]:
        try:
            response = requests.get(url, timeout=self.timeout, headers={"User-Agent": self.user_agent})

            missing_headers = []
            security_headers = {"X-Content-Type-Options": "nosniff", "X-Frame-Options": ["DENY", "SAMEORIGIN"],
                "X-XSS-Protection": "1; mode=block", "Strict-Transport-Security": None, "Content-Security-Policy": None}

            for header, expected_values in security_headers.items():
                if header not in response.headers:
                    missing_headers.append({"header": header, "recommendation": f"Add {header} header for security"})
                elif expected_values and response.headers[header] not in expected_values:
                    missing_headers.append({"header": header, "current_value": response.headers[header],
                        "recommended_values": expected_values})

            return {"missing_security_headers": missing_headers}

        except requests.RequestException as e:
            return {"error": f"Failed to check security headers: {str(e)}"}

    def execute_attack(self, target: str, options: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        # Ensure target is a valid URL
        if not target.startswith(('http://', 'https://')):
            target = f"http://{target}"

        try:
            # Verify target is accessible
            response = requests.get(target, timeout=self.timeout)
            if response.status_code >= 400:
                return {"success": False, "details": f"Target {target} returned HTTP {response.status_code}",
                    "severity": "info", "recommendations": ["Verify target URL is correct and accessible"]}
        except requests.RequestException as e:
            return {"success": False, "details": f"Cannot connect to {target}: {str(e)}", "severity": "info",
                "recommendations": ["Check network connectivity and target availability"]}

        # Execute vulnerability tests
        results = {}
        results.update(self._test_xss_vulnerability(target))
        results.update(self._test_sql_injection(target))
        results.update(self._check_security_headers(target))

        # Aggregate findings
        total_vulnerabilities = (
                len(results.get("xss_vulnerabilities", [])) + len(results.get("sql_vulnerabilities", [])) + len(
            results.get("missing_security_headers", [])))

        if total_vulnerabilities > 0:
            severity = "high" if any(
                [results.get("xss_vulnerabilities"), results.get("sql_vulnerabilities")]) else "medium"

            recommendations = ["Implement input validation and output encoding",
                "Use parameterized queries to prevent SQL injection", "Configure appropriate security headers",
                "Perform regular security assessments", "Implement Content Security Policy"]

            return {"success": True, "details": f"Found {total_vulnerabilities} security issues on {target}",
                "severity": severity, "recommendations": recommendations, "details_extended": results}
        else:
            return {"success": False, "details": f"No obvious vulnerabilities found on {target}", "severity": "low",
                "recommendations": ["Continue regular security monitoring",
                    "Consider more comprehensive vulnerability assessment",
                    "Implement security best practices as preventive measures"], "details_extended": results}

    def get_capabilities(self) -> List[str]:
        return ["web_vulnerability_scan", "xss_detection", "sql_injection_test", "security_header_check"]